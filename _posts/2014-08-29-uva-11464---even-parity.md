---
categories: Posts
date: 2014-08-29 00:00:00
title: UVa 11464 - Even Parity
tags: []
layout: post
---

## 传送门

[UVa 11464 - Even Parity](http://www.bnuoj.com/v3/problem_show.php?pid=19882)

## 题意

给出一个原始矩阵，求最少数目变动，将0变为1，使得每个元素上下左右之和是偶数。

## 思路

用类似状态压缩的方法表示出第一行的状态，然后依次往下递推。

## 代码


```c++
#include <bits/stdc++.h>
#define LL long long
#define lowbit(x) ((x) & (-x))
const int MAXN = 15 + 5;
const int INF = 0x3f3f3f3f;
using namespace std;
 
int mp[MAXN][MAXN], n, tmp[MAXN][MAXN];
 
int Solve(int k)
{
    memset(tmp, 0, sizeof tmp);
    int i, j;
    for (i = 0; i < n; i++)
        if ((1 << i) & k)
            tmp[0][i] = 1;
        else if (mp[0][i] == 1)
            return INF;
    for (i = 1; i < n; i++)
    {
        for (j = 0; j < n; j++)
        {
            int cur = 0;
            if (i > 1)
                cur += tmp[i - 2][j];
            if (j > 0)
                cur += tmp[i - 1][j - 1];
            if (j < n - 1)
                cur += tmp[i - 1][j + 1];
            tmp[i][j] = cur % 2;
            if (tmp[i][j] == 0 && mp[i][j] == 1)
                return INF;
        }
    }
    int cnt = 0;
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            if (tmp[i][j] != mp[i][j])
                cnt++;
    return cnt;
}
 
int main()
{
    //freopen("input.txt", "r", stdin);
    int T, i, j, cases = 0;
    scanf("%d", &T);
    while (T--)
    {
        scanf("%d", &n);
        int ans = INF;
        for (i = 0; i < n; i++)
            for (j = 0; j < n; j++)
                scanf("%d", ∓[i][j]);
        for (i = 0; i < (1 << n); i++)
            ans = min(ans, Solve(i));
        if (ans == INF) ans = -1;
        printf("Case %d: %d\n", ++cases, ans);
    }
    return 0;
}
```