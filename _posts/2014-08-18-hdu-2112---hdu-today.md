---
categories: Posts
date: 2014-08-18 00:00:00
title: HDU 2112 - HDU Today
tags: []
layout: post
---

## 传送门

[HDU 2112 - HDU Today](http://vjudge.net/vjudge/problem/viewProblem.action?id=22265)

## 思路

用map存序号，然后和以前一样。

一开始我是先存在起点和终点，到最后再取出他们的序号，又无限WA，又看了几十遍Dijkstra。

原因是可能终点根本就不在map里，当然没有什么序号可以取出来。

先前用邻接表写的，后来到判断重边的时候就愣住了。默默地换回了邻接矩阵（ ＴДＴ）

## 代码


```c++
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
#include <vector>
#include <iostream>
#include <string>
#include <map>
using namespace std;
#define LL long long
#define MP(a, b) make_pair(a, b)
const int MAXN = 150 + 5;
const int INF = 0x3f3f3f3f;
 
typedef pair<int, int> pii;
priority_queue<pii, vector<pii>, greater<pii> >qu;
int mp[MAXN][MAXN], k;
map<string, int> dic;
int n, d[MAXN];
 
void Dijkstra()
{
    d[0] = 0;
    qu.push(MP(d[0], 0));
    while (!qu.empty())
    {
        pii u = qu.top();
        qu.pop();
        int x = u.second;
        if (d[x] != u.first)
            continue;
        for (int i = 0; i < k; i++)
        {
            if (d[i] > d[x] + mp[x][i])
            {
                d[i] = d[x] + mp[x][i];
                qu.push(MP(d[i], i));
            }
        }
    }
}
 
int main()
{
    //freopen("input.txt", "r", stdin);
    ios::sync_with_stdio(false);
 
    int n, i, j, ist, ied, v;
    char st[40], ed[40], start[40], endd[40];
    while (scanf("%d", &n), n != -1)
    {
        memset(d, 0x3f, sizeof d);
        for (i = 0; i < MAXN; i++)
            for (j = 0; j < MAXN; j++)
                mp[i][j] = (i == j ? 0 : INF);
        dic.clear();
        k = 2;
        scanf("%s%s", start, endd);
        dic[start] = 0;
        dic[endd] = 1;
        for (i = 0; i < n; i++)
        {
            scanf("%s%s%d", st, ed, &v);
            if (!dic.count(st))
                dic[st] = k++;
            if (!dic.count(ed))
                dic[ed] = k++;
            if (mp[dic[st]][dic[ed]] > v)
                mp[dic[st]][dic[ed]] = mp[dic[ed]][dic[st]] = v;
        }
        if (strcmp(start, endd) == 0)
        {
            printf("0\n");
            continue;
        }
        Dijkstra();
        printf("%d\n", d[1] == INF ? -1 : d[1]);
    }
    return 0;
}
```