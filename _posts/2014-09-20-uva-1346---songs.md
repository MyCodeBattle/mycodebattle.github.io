---
categories: Posts
date: 2014-09-20 00:00:00
title: UVa 1346 - Songs
tags: []
layout: post
---

## 题意

有N个唱片，每个唱片有ID，长度和频率

sum = f[i] * (len[i] + len[i + 1]….. + len[n])，求sum最小的时候第k个唱片的id。

## 思路

可以用相邻交换法证明当f1 / l1 > f2 / l2时，sum1 > sum2。

所以排个序就行。

## 代码


```c++
#include <cstdio>
#include <algorithm>
#include <functional>
#include <stack>
#include <set>
#include <iostream>
#include <string>
#include <vector>
#include <queue>
#include <cstring>
#include <string>
#include <sstream>
#include <map>
#include <cmath>
#define LL long long
#define lowbit(x) ((x) & (-x))
#define MP(a, b) make_pair(a, b)
#define MS(arr, num) memset(arr, num, sizeof(arr))
#define PB push_back
#define ROP freopen("input.txt", "r", stdin);
const double PI = acos(-1.0);
const int INF = 0x3f3f3f3f;
using namespace std;
const int MAXN = (1 << 16) + 5;
 
struct POINT
{
    int id, len;
    double fre;
    bool operator < (const POINT &a) const
    {
        return len * a.fre < a.len * fre;
    }
}pit[MAXN];
 
int main()
{
    //ROP;
    int n, i, j;
    while (~scanf("%d", &n))
    {
        for (i = 0; i < n; i++) scanf("%d%d%lf", &pit[i].id, &pit[i].len, &pit[i].fre);
        sort(pit, pit + n);
        int a;
        scanf("%d", &a);
        nth_element(pit, pit + a - 1, pit + n);
        printf("%d\n", pit[a - 1].id);
    }
    return 0;
}
```