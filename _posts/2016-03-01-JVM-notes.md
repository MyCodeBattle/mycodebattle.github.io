---
title: JVM学习笔记
layout: post
date: 2016-03-01
categories: 
---

<s>我就想看看我能写多久</s>

# 垃圾收集器与内存分配策略

## 对象已死吗

### 引用计数算法

该算法给对象添加一个引用计数器，每当一个地方引用它时，计数器加1，当计数器为0的时候就被判断为不可能再被使用的。

但是JVM没有使用引用计数算法，最主要的原因是它存在对象间**相互引用**问题。

比如说A.x = B, B.x = A，那么当他们两个都指向null时，引用计数还是不为0，无法启动GC。

### 可达性分析算法

主流语言都是通过可达性分析 (Reachability Analysis)来判断对象是否存活。
这个算法通过一系列被称为`GC Roots`的对象作为起点，向下搜索，走过的路成为**引用链 (Reference Chain)**。当一个对象到GC Roots没有任何引用的时候不可达。
就是判断超级源点的图的连通性。

Java中，可作为GC Roots的对象包括：

- 虚拟机栈中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中 JNI (Native) 引用的对象。

### 再谈引用

Java把引用分为强引用、软引用、弱引用、虚引用，强度依次减弱。

- 强引用就是代码之中普遍存在的，类似`Object o = new Object()`这样的引用。只要强引用还存在，GC就不会回收被引用的对象。
- 软引用用来描述一些还有用但并非必须的对象，在系统将要发生内存溢出异常之前，会把这些对象列进回收范围之中进行第二次回收。
- 被弱引用关联的对象只能活到下一次 GC 之前。当 GC 开始时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
- 虚引用只是用来在这个对象被回收时收到一个系统通知。

### 生存还是死亡

一个对象真正死亡，至少要经历两次标记。
如果对象不可达，会被第一次标记并进行筛选，条件是该对象有没有必要执行`finalize`方法。
如果该方法没被重写或者已经被调用过，对象就会被放入「即将回收」的集合里，否则放入 F-Queue 队列中等待执行`finalize`方法，如果对象能在该方法中成功与一个在 GC Roots上的对象建立起引用，就能逃脱被回收的命运。

`finalize`代价高昂，我们应该避免使用。
这里有点问题啊，如果没重写`finalize`，就只进行一次标记了，作者怎么说至少两次。


### 回收方法区

JVM 规范中说过可以不要求虚拟机在方法区实现垃圾收集。

永久代的垃圾收集主要回收**废弃常量**和**无用的类**。
要判断一个类是「无用的类」，需要同时满足以下三个条件：

- 该类所有的实例都已经被回收。
- 加载该类的`ClassLoader`已经被回收。
- 该类的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类方法。

虚拟机**可以**对满足上面条件的无用类进行回收。

## 垃圾收集算法

### 标记 - 清除算法

它先标记出所有需要回收的对象，标记完后统一回收。
不足：
- 效率不高。
- 标记清除之后会产生大量不连续的碎片，不好分配较大的对象。


### 复制算法

把内存分成大小相等的两块，每次只使用其中一块。当这一块的用完了，把还存活着的对象移动到另一块上，清理这一块的空间。
这种算法的代价是只能使用原来一半的内存。

现在的商业虚拟机都是采用这种收集算法来回收新生代。据研究表明，新生代中98%的对象是「朝生夕死」的，所以不需要按照1：1的比例划分内存。
所以将内存划分为一块较大的`Eden`空间和两块较小的`Survivor`空间，每次使用`Eden`和其中一块`Survivor`。回收时，把那两块活着的对象复制到剩下那一块。
HotSpot 虚拟机默认的Eden和Survivor的比例是8：1，也就是每次新生代可用内存有10%被浪费。
但是我们不能担保每次只有不多于10%的对象存活，所以当空间不够用时，那些存活的对象通过**分配担保（Handle Promotion）**进入老年代。


### 标记 - 整理算法

因为复制算法复制操作多的话效率不加，所以老年代一般不用。
用的是`标记 - 整理`算法。
标记过程和`标记 - 清除`一样，然后把所有存活的对象向一端移动，直接清理掉端边界以外的内存。

### 分代收集算法

这个应该不是一种具体的算法，只是根据对象的不同存活周期将内存分为不同的几块，然后看情况选用具体的算法。