---
categories: Posts
date: 2014-12-01 00:00:00
title: UVa 10037 - Bridge (贪心)
tags: []
layout: post
---

## 题意

N个人要过河，每次最多走两个人，只有一根手电筒，求最少过河时间。

## 思路

带人过河有两种方法

设走得最快的两个为a, b，并且假设他们现在在对岸。现在c和d要过河。

a  
a c  
a  
a d

或者

a  
c d  
b  
a b

前者的时间是a + c + a + d = 2a + c + d  
后者的时间是a + c + 2b

所以每运两个人过去的时候都要考虑一下这两种方式，选时间少的那种。

还有一个问题。一开始我是按从小到大算的。但是这样的话

1 2 3 100 100这组数据，会先运走3 100，最后运100，显然应该先运100 100。

所以应该从大到小排序。

然后我用队列记录了选择哪一种方法，直接输出也可以，不过看着太乱了。

## 代码


```c++
#include <cstdio>
#include <stack>
#include <set>
#include <iostream>
#include <string>
#include <vector>
#include <queue>
#include <cstdlib>
#include <functional>
#include <cstring>
#include <algorithm>
#include <cctype>
#include <string>
#include <map>
#include <iomanip>
#include <cmath>
#define LL long long
#define ULL unsigned long long
#define SZ(x) (int)x.size()
#define Lowbit(x) ((x) & (-x))
#define MP(a, b) make_pair(a, b)
#define MS(arr, num) memset(arr, num, sizeof(arr))
#define PB push_back
#define F first
#define S second
#define ROP freopen("input.txt", "r", stdin);
#define MID(a, b) (a + ((b - a) >> 1))
#define LC rt << 1, l, mid
#define RC rt << 1|1, mid + 1, r
#define LRT rt << 1
#define RRT rt << 1|1
#define BitCount(x) __builtin_popcount(x)
#define BitCountll(x) __builtin_popcountll(x)
#define LeftPos(x) 32 - __builtin_clz(x) - 1
#define LeftPosll(x) 64 - __builtin_clzll(x) - 1
const double PI = acos(-1.0);
const int INF = 0x3f3f3f3f;
using namespace std;
const double eps = 1e-6;
const int MAXN = 1100 + 10;
const int MOD = 1000007;
 
typedef pair<int, int> pii;
typedef vector<int>::iterator viti;
typedef vector<pii>::iterator vitii;
 
vector<int> arr;
queue<int> step;
 
int main()
{
    //ROP;
    int T, i, j;
    scanf("%d", &T);
    while (T--)
    {
        arr.clear();
        int n;
        scanf("%d", &n);
        for (i = 0; i < n; i++)
        {
            int tmp;
            scanf("%d", &tmp);
            arr.PB(tmp);
        }
        sort(arr.begin(), arr.end(), greater<int>());
        int sz = SZ(arr);
        if (n == 2)
        {
            printf("%d\n", arr[sz - 2]);
            printf("%d %d\n", arr[sz - 1], arr[sz - 2]);
            if (T) puts("");
            continue;
        }
        if (n == 1)
        {
            printf("%d\n", arr[sz - 1]);
            printf("%d\n", arr[sz - 1]);
            if (T) puts("");
            continue;
        }
        int fst = arr[sz - 1], sec = arr[sz - 2], ans = sec;
        if (n == 3)
        {
            printf("%d\n", ans + fst + arr[sz - 3]);
            printf("%d %d\n", fst, sec);
            printf("%d\n", fst);
            printf("%d %d\n", fst, arr[sz - 3]);
            if (T) puts("");
            continue;
        }
        arr.pop_back(); arr.pop_back();
        for (i = 0; i + 1 < SZ(arr); i += 2)
        {
            int tmp = arr[i] + sec * 2 + fst;
            int _tmp = arr[i] + 2 * fst + arr[i + 1];
            if (tmp > _tmp)
            {
                ans += _tmp;
                step.push(1);
            }
            else
            {
                ans += tmp;
                step.push(-1);
            }
        }
        if (n & 1) ans += fst + arr.back();
        printf("%d\n", ans);
        printf("%d %d\n", fst, sec);
        for (i = 0; i + 1 < SZ(arr); i += 2)
        {
            printf("%d\n", fst);
            if (step.front() < 0)
            {
                printf("%d %d\n", arr[i + 1], arr[i]);
                printf("%d\n", sec);
                printf("%d %d\n", fst, sec);
            }
            else
            {
                printf("%d %d\n", fst, arr[i + 1]);
                printf("%d\n", fst);
                printf("%d %d\n", fst, arr[i]);
            }
            step.pop();
        }
        if (n & 1)
        {
            printf("%d\n", fst);
            printf("%d %d\n", fst, arr.back());
        }
        if (T) puts("");
 
    }
    return 0;
}
```