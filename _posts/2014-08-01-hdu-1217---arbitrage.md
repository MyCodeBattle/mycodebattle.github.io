---
categories: Posts
date: 2014-08-01 00:00:00
title: HDU 1217 - Arbitrage
tags: []
layout: post
---

## 传送门

[HDU 1217 - Arbitrage](http://vjudge.net/vjudge/problem/viewProblem.action?id=22312)

## 题意

有些人把货币换成别的货币，再换回来，由于汇率的不同，可以赚钱。

判断存不存在套汇的情况。

## 思路

用Floyd

如果存在套汇的情况，说明mp[i][i] > 1。

## 代码


```c++
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
#include <vector>
#include <iostream>
#include <string>
#include <map>
using namespace std;
#define LL long long
#define MP(a, b) make_pair(a, b)
const int MAXN = 30 + 5;
const int INF = 0x3f3f3f3f;
 
typedef pair<int, int> pii;
priority_queue<pii, vector<pii>, greater<pii> >qu;
double mp[MAXN][MAXN];
map<string, int> dic;
int n, d[MAXN], k, cases = 0;
 
void Floyd()
{
    for (int k = 0; k < n; k++)
        for (int i = 0; i < n; i++)
        {
            if (mp[i][i] > 1)
            {
                printf("Case %d: Yes\n", ++cases);
                return;
            }
            if (mp[i][k] != 0)
                for (int j = 0; j < n; j++)
                    mp[i][j] = max(mp[i][j], mp[i][k] * mp[k][j]);
        }
    printf("Case %d: No\n", ++cases);
}
 
int main()
{
    //freopen("input.txt", "r", stdin);
    int nr, i, j;
    char str[100], sstr[100];
    double er;
    while (scanf("%d", &n), n)
    {
        dic.clear();
        for (i = 0; i < n; i++)
            for (j = 0; j < n; j++)
                mp[i][j] = (i == j ? 1 : 0);
        int k = 0;
        for (i = 0; i < n; i++)
        {
            scanf("%s", str);
            dic[str] = k++;
        }
        scanf("%d", &nr);
        for (i = 0; i < nr; i++)
        {
            scanf("%s%lf%s", str, &er, sstr);
            mp[dic[str]][dic[sstr]] = er;
        }
        Floyd();
    }
    return 0;
}
```