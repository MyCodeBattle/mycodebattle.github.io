---
title: JVM学习笔记
layout: post
date: 2016-03-01
categories: 
---

<s>我就想看看我能写多久</s>

# 垃圾收集器与内存分配策略

## 对象已死吗

### 引用计数算法

该算法给对象添加一个引用计数器，每当一个地方引用它时，计数器加1，当计数器为0的时候就被判断为不可能再被使用的。

但是JVM没有使用引用计数算法，最主要的原因是它存在对象间**相互引用**问题。

比如说A.x = B, B.x = A，那么当他们两个都指向null时，引用计数还是不为0，无法启动GC。

### 可达性分析算法

主流语言都是通过可达性分析 (Reachability Analysis)来判断对象是否存活。
这个算法通过一系列被称为`GC Roots`的对象作为起点，向下搜索，走过的路成为**引用链 (Reference Chain)**。当一个对象到GC Roots没有任何引用的时候不可达。
就是判断超级源点的图的连通性。

Java中，可作为GC Roots的对象包括：

- 虚拟机栈中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中 JNI (Native) 引用的对象。

### 再谈引用

Java把引用分为强引用、软引用、弱引用、虚引用，强度依次减弱。

- 强引用就是代码之中普遍存在的，类似`Object o = new Object()`这样的引用。只要强引用还存在，GC就不会回收被引用的对象。
- 软引用用来描述一些还有用但并非必须的对象，在系统将要发生内存溢出异常之前，会把这些对象列进回收范围之中进行第二次回收。
- 被弱引用关联的对象只能活到下一次 GC 之前。当 GC 开始时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
- 虚引用只是用来在这个对象被回收时收到一个系统通知。

### 生存还是死亡

一个对象真正死亡，至少要经历两次标记。
如果对象不可达，会被第一次标记。