---
categories: Posts
date: 2014-09-01 00:00:00
title: ACDream 1209 - qj的招待会
tags: []
layout: post
---

#  [ACDream 1209 - qj的招待会](/2014/09/ACDream-1209/ "ACDream 1209 - qj的招待会")

By [MyCodeBattle](http://mycodebattle.gitcafe.io/about "MyCodeBattle")

Published Sep 18 2014 21:40

**Contents**

  1. 1. 传送门
  2. 2. 思路
  3. 3. 代码

## 传送门

[ACDream 1209 - qj的招待会](http://acdream.info/problem?pid=1209)

## 思路

单源最短路。从终点Dijkstra一遍就行。

## 代码
    
    
    1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677

| 
    
    
    ​#include <cstdio>#include <algorithm>#include <functional>#include <stack>#include <iostream>#include <string>#include <vector>#include <queue>#include <cstring>#include <string>#include <sstream>#include <map>#include <cmath>#define LL long long#define lowbit(x) ((x) & (-x))#define MP(a, b) make_pair(a, b)const int MAXN = 1000 + 5;const int INF = 0x3f3f3f3f;using namespace std;  typedef pair<int, int> pii;typedef vector<int>::iterator viti;typedef vector<pii>::iterator vitii;  vector<pii> mp[MAXN];priority_queue<pii, vector<pii>, greater<pii> >pqu;  int d[MAXN];  void Dijkstra(int st){    memset(d, INF, sizeof d);    d[st] = 0;    pqu.push(MP(d[st], st));    while (!pqu.empty())    {        pii u = pqu.top(); pqu.pop();        int x = u.second, curDis = u.first;        if (u.first != d[x]) continue;        for (vitii it = mp[x].begin(); it != mp[x].end(); it++)        {            int t = it->first;            if (d[t] > curDis + it->second)            {                d[t] = curDis + it->second;                pqu.push(MP(d[t], t));            }        }    }}  int main(){    int n, i, j;    scanf("%d", &n);    for (i = 0; i < n; i++)    {        char ch[10], cch[10];        int dis, a, b;        scanf("%s%s%d", ch, cch, dis);        if (isupper(ch[0])) a = ch[0]- 'A' + 26;        else a = ch[0] - 'a';        if (isupper(cch[0])) b = ch[0] - 'A' + 26;        else b = cch[0] - 'a';        mp[a].push_back(MP(b, dis)); mp[b].push_back(MP(a, dis));        int st = 'Z' - 'A';        Dijkstra(st);        int pos, ans = INF;        for (i = 0; i < 55; i++)        {            ans = min(ans, d[i]);            pos = i;        }        printf("%c %d\n", pos + 'A', ans);    }    return 0;}  
  
---|---  
  
[Solving Reports](/categories/Solving-Reports/)

[Online Judge - ACDream](/tags/Online-Judge-ACDream/)[Algorithm - Shortest Path](/tags/Algorithm-Shortest-Path/)
