---
categories: Posts
date: 2014-08-08 00:00:00
title: UVa 10205 - Stack 'em Up
tags: []
layout: post
---

## 传送门

[UVa 10205 - Stack ‘em Up](http://vjudge.net/problem/viewProblem.action?id=21176)

## 题意

题意看得蛋疼。。看了好久才明白

前面的一堆话都没用。

有个人会N种洗牌的方法，把每种方法告诉我们。现在要求我们输出按照他的方法洗过后的牌。数字i在第j个位置就说明本来在i位置的牌洗了之后就在j了。

先输入组数，然后输入那个人会的洗牌的方法数n，然后是洗牌的方法，最后n行是他的方法的先用使用顺序

## 思路

记录下每种方法，然后模拟就行。

## 代码


```c++
#include <bits/stdc++.h>
using namespace std;
#define LL long long
#pragma comment(linker, "/STACK:102400000,102400000")
const int MAXN = 52 + 8;
const int N = 52;
const char value[][10] = { "Ace", "2", "3", "4", "5", "6", "7", "8", "9", "10", "Jack", "Queen", "King"};
const char suit[][10] = { "Clubs", "Diamonds", "Hearts", "Spades" };
 
int way[105][MAXN], temp[MAXN], ans[MAXN], n;
 
void Read()
{
    scanf("%d%", &n);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= N; j++)
            scanf("%d%*c", &way[i][j]);
    for (int i = 1; i <= N; i++)
        ans[i] = i;
}
 
void Solve(int *n)
{
    for (int i = 1; i <= N; i++)
        temp[i] = ans[n[i]];
    memcpy(ans, temp, sizeof temp);
}
 
int main()
{
    //freopen("input.txt", "r", stdin);
    int T, i, j, num;
    char order[10];
    scanf("%d", &T);
    while (T--)
    {
        Read();
        while (gets(order) && order[0] != 0)
        {
            sscanf(order, "%d", #);
            Solve(way[num]);
        }
        for (i = 1; i <= N; i++)
            printf("%s of %s\n", value[ans[i] % 13], suit[(ans[i] - 1) / 13]);
        if (T)
            puts("");
    }
    return 0;
}
```