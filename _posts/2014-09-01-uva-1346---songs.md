---
categories: Posts
date: 2014-09-01 00:00:00
title: UVa 1346 - Songs
tags: []
layout: post
---

#  [UVa 1346 - Songs](/2014/09/UVa-1346/ "UVa 1346 - Songs")

By [MyCodeBattle](http://mycodebattle.gitcafe.io/about "MyCodeBattle")

Published Sep 20 2014 13:56

**Contents**

  1. 1. 题意
  2. 2. 思路
  3. 3. 代码

## 题意

有N个唱片，每个唱片有ID，长度和频率

sum = f[i] * (len[i] + len[i + 1]….. + len[n])，求sum最小的时候第k个唱片的id。

## 思路

可以用相邻交换法证明当f1 / l1 > f2 / l2时，sum1 > sum2。

所以排个序就行。

## 代码
    
    
    1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950

| 
    
    
    #include <cstdio>#include <algorithm>#include <functional>#include <stack>#include <set>#include <iostream>#include <string>#include <vector>#include <queue>#include <cstring>#include <string>#include <sstream>#include <map>#include <cmath>#define LL long long#define lowbit(x) ((x) & (-x))#define MP(a, b) make_pair(a, b)#define MS(arr, num) memset(arr, num, sizeof(arr))#define PB push_back#define ROP freopen("input.txt", "r", stdin);const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;using namespace std;const int MAXN = (1 << 16) + 5; struct POINT{    int id, len;    double fre;    bool operator < (const POINT &a) const    {        return len * a.fre < a.len * fre;    }}pit[MAXN]; int main(){    //ROP;    int n, i, j;    while (~scanf("%d", &n))    {        for (i = 0; i < n; i++) scanf("%d%d%lf", &pit[i].id, &pit[i].len, &pit[i].fre);        sort(pit, pit + n);        int a;        scanf("%d", &a);        nth_element(pit, pit + a - 1, pit + n);        printf("%d\n", pit[a - 1].id);    }    return 0;}  
  
---|---  
  
[Solving Reports](/categories/Solving-Reports/)

[Online Judge - UVa](/tags/Online-Judge-UVa/)[Foundation - Greedy](/tags/Foundation-Greedy/)
